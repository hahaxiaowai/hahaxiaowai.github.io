import{_ as i,o as a,c as n,al as t}from"./chunks/framework.BpfVCkTD.js";const r=JSON.parse('{"title":"js 基础","description":"","frontmatter":{"title":"js 基础","date":"2026-02-20 23:44:00","categories":["web"],"tags":["基础"],"publish":false},"headers":[],"relativePath":"blogs/2026/js.md","filePath":"blogs/2026/js.md","lastUpdated":1771680005000}'),e={name:"blogs/2026/js.md"};function l(p,s,h,k,d,E){return a(),n("div",null,[...s[0]||(s[0]=[t(`<h2 id="作用域与变量提升" tabindex="-1">作用域与变量提升 <a class="header-anchor" href="#作用域与变量提升" aria-label="Permalink to &quot;作用域与变量提升&quot;">​</a></h2><p>作用域是指变量和函数的可访问范围，JavaScript中有全局作用域和函数作用域两种类型。变量提升是指在函数执行之前，变量和函数声明会被提升到作用域的顶部，这意味着在函数内部可以访问到变量和函数，即使它们是在声明之前定义的。例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中，变量a被提升到函数的顶部，因此在第一次console.log(a)时，a的值是undefined，而不是10。变量提升只会提升变量声明，而不会提升变量的赋值，因此在第一次console.log(a)时，a的值是undefined。函数提升也是类似的，函数声明会被提升到作用域的顶部，因此在函数内部可以访问到函数，即使它是在声明之前定义的。例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Hello, World!&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中，函数example被提升到作用域的顶部，因此在调用example()时，函数已经被定义，可以正常执行。需要注意的是，变量提升和函数提升只会提升声明，而不会提升赋值，因此在使用变量和函数之前，最好先进行声明和定义，以避免出现undefined的情况。</p><h2 id="iife-immediately-invoked-function-expression" tabindex="-1">IIFE（Immediately Invoked Function Expression） <a class="header-anchor" href="#iife-immediately-invoked-function-expression" aria-label="Permalink to &quot;IIFE（Immediately Invoked Function Expression）&quot;">​</a></h2><p>IIFE是一种立即执行函数表达式，它可以创建一个独立的作用域，避免变量污染全局作用域。IIFE的语法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里是IIFE的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})();</span></span></code></pre></div><p>在这个例子中，函数被包裹在一个括号中，形成一个函数表达式，然后立即调用这个函数。IIFE可以接受参数，例如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>在这个例子中，IIFE接受一个参数name，并在函数内部使用这个参数输出一个问候语。IIFE在JavaScript中非常常见，特别是在模块化开发中，可以用来创建一个独立的作用域，避免变量污染全局作用域，同时也可以用来封装代码，保护变量和函数不被外部访问。</p>`,12)])])}const g=i(e,[["render",l]]);export{r as __pageData,g as default};
