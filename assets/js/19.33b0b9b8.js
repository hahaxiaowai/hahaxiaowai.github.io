(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{523:function(e,t,a){"use strict";a.r(t);var r=a(6),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"简述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[e._v("#")]),e._v(" 简述")]),e._v(" "),a("p",[e._v("当下的设计师们非常喜爱使用渐变色，从实际效果上也确实好看一些，不过地图上的渐变看似简单，实则有时让开发者十分头痛。\n在mapbox里，最常见的应该是线面渐变，在已有的api里，"),a("a",{attrs:{href:"https://docs.mapbox.com/mapbox-gl-js/example/line-gradient/",target:"_blank",rel:"noopener noreferrer"}},[e._v("线渐变"),a("OutboundLink")],1),e._v("可以轻松实现,但是面渐变，以及体（fill-extrusion）渐变就变得复杂很多，今天要讲解的是面图层整体渐变的一种实现方式。")]),e._v(" "),a("h2",{attrs:{id:"整体逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整体逻辑"}},[e._v("#")]),e._v(" 整体逻辑")]),e._v(" "),a("p",[e._v("首先要明确的是，当前实现的效果是整个图层的渐变，也就是不区分"),a("code",[e._v("feature")]),e._v("的个数。")]),e._v(" "),a("ol",[a("li",[e._v("新增两个自定义图层属性 "),a("code",[e._v("fill-pattern-repeat")]),e._v(","),a("code",[e._v("fill-bound")])]),e._v(" "),a("li",[e._v("将瓦片的墨卡托范围传入shader")]),e._v(" "),a("li",[e._v("根据 "),a("code",[e._v("u_repeat")]),e._v(" 判断是否执行即可")])]),e._v(" "),a("h2",{attrs:{id:"具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[e._v("#")]),e._v(" 具体实现")]),e._v(" "),a("p",[e._v("创建一个面图层,设置"),a("code",[e._v("fill-pattern")]),e._v(" ，添加一个图片，默认效果下，图片会不断重复，如果我们让图片根据一个属性判断是否让图片重复，那么就会实现我们想要的效果")]),e._v(" "),a("h3",{attrs:{id:"添加-fill-pattern-repeat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加-fill-pattern-repeat"}},[e._v("#")]),e._v(" 添加 "),a("code",[e._v("fill-pattern-repeat")])]),e._v(" "),a("p",[e._v("1.在v8.json中找到fill相关属性，可以直接在"),a("code",[e._v("fill-pattern")]),e._v("下面添加一个"),a("code",[e._v("fill-pattern-repeat")]),e._v(",类型为"),a("code",[e._v("boolean")]),e._v(",默认为true,常量。至于下面的触发条件，可填可不填，影响不大\n2.在"),a("code",[e._v("fill_attribute_style.js")]),e._v(" 中设置相关属性，并且需要将layer传过来，这样才能获取设置的值\n3.在"),a("code",[e._v("fill_pattern.frag.glsl")]),e._v("中引入"),a("code",[e._v("u_repeat")]),e._v(" 根绝这个值进行不停的代码")]),e._v(" "),a("h3",{attrs:{id:"添加-fill-bound"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加-fill-bound"}},[e._v("#")]),e._v(" 添加 "),a("code",[e._v("fill-bound")])]),e._v(" "),a("p",[e._v("原本的fill-pattern是通过点的瓦片内坐标获取图片的uv，这就会让图片按照一定的大小进行重复贴图，注意这里并不是说图片的uv完全等于瓦片的大小。如果我们想给整个图层贴一张不重复贴图，那么需要把整个图层的范围传进去，然后计算瓦片的范围，这样才能算出一个正确的UV\n1.计算图层范围，这在mapbox中并没有现成的办法，所以需要自己写方法计算，这里就会面临一个问题，如果数据源是服务，那么服务应提供图层的范围，这可能需要另外的接口调用。以下提供geojson获取图层范围的方法\n2.仿照"),a("code",[e._v("fill-pattern-repeat")]),e._v("新增一个属性"),a("code",[e._v("fill-bound")]),e._v(" 类型为Array,数据驱动，然后将计算好的东西传进去。有一点需要注意，这里我选择将经纬度转为墨卡托坐标，传了进去，严格意义讲这并不是Cesium那样的墨卡托坐标，而是可直接用于webgl计算的坐标")]),e._v(" "),a("h3",{attrs:{id:"计算瓦片范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算瓦片范围"}},[e._v("#")]),e._v(" 计算瓦片范围")]),e._v(" "),a("p",[e._v("只有图层范围无法计算图片UV，需要获取瓦片范围。")]),e._v(" "),a("ol",[a("li",[e._v("在Tile中，我们可以获取瓦片的行列号，通过计算，可以把这个行列号转换为墨卡托坐标（webgl）以下是计算方式")]),e._v(" "),a("li",[e._v("计算好后，你可以选择将图层范围和瓦片范围分别传进去，然后计算uv，也可以讲计算好的uv直接传进去，在片元着色器中，使用该uv替换原来使用的uv,你会发现v是反的，所以再取一次反即可。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);