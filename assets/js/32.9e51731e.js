(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{536:function(t,a,r){"use strict";r.r(a);var o=r(6),e=Object(o.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"简述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[t._v("#")]),t._v(" 简述")]),t._v(" "),r("p",[t._v("针对GIS项目的相关性能优化")]),t._v(" "),r("h2",{attrs:{id:"操作dom元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#操作dom元素"}},[t._v("#")]),t._v(" 操作dom元素")]),t._v(" "),r("p",[t._v("平常我们用Dom元素创建一些标签，比如mapbox的marker，根据经纬度计算出屏幕坐标，最后渲染一个dom元素，这个功能十分消耗性能，特别是在做动画相关的东西时，帧率很容易降低。以下是已知解决方案")]),t._v(" "),r("ol",[r("li",[t._v("抽帧，如果在做动画相关的dom,可以抽取二分之一，或者四分之一，减少dom操作次数，也可以做进一步的优化，比如对比前后屏幕坐标的变化量，如果这个变化量小那么不进行dom操作")]),t._v(" "),r("li",[t._v("超出屏幕外的内容不进行操作，判断transform的xy值域，注意在边缘位置要根据实际情况设置更新dom,同时也要注意dom本身长度与屏幕的之间的关系。")])]),t._v(" "),r("h2",{attrs:{id:"模型减少重复请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模型减少重复请求"}},[t._v("#")]),t._v(" 模型减少重复请求")]),t._v(" "),r("p",[t._v("以three举例，他的loader已经做了图片的缓存，当图片需要第二次请求时，会判断缓存中是否有这张图片，如果有，便直接拿来用，不再请求。")]),t._v(" "),r("p",[t._v("这里有一个需要注意的地方，现有的loader,在调用loader.load的时候会记录缓存，但是当你第二次调用时，之前的缓存会清除掉，这样的逻辑实际上是正确的，因为调用load就是在加载新的模型，模型与模型之间是没有关系的，所以这么做是对的。但是当进行分块（瓦片）模型加载，会多次调用这个方法，这个时候便需要改造一下这个缓存机制了。")])])}),[],!1,null,null,null);a.default=e.exports}}]);