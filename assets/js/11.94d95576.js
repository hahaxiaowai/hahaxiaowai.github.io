(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{510:function(t,e,a){"use strict";a.r(e);var r=a(5),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("h2",{attrs:{id:"问题说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题说明"}},[t._v("#")]),t._v(" 问题说明")]),t._v(" "),a("p",[t._v("在我们使用Vue作为开发框架时，我们会习惯于将数据挂载到Vue示例上，方便监听数据以及销毁和调用。对于地图也是如此，我们希望将地图实例同样挂载到Vue实例（某一组件）上，地图数据量不大时，我们发现不了性能差异，但是当我们数据量变大，就会发现地图在拖拽时变卡，性能大大降低，该如何解决呢？")])]),a("h2",{attrs:{id:"问题所在"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题所在"}},[t._v("#")]),t._v(" 问题所在")]),t._v(" "),a("p",[t._v("造成这个原因的便是Vue的监听数据变化造成的，Vue实例与地图实例都有各自的监听事件，并且地图实例的属性（相机等）经常发生变化，每次变化都会触发Vue的监听数据的事件，导致性能降低。")]),t._v(" "),a("h2",{attrs:{id:"尝试解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尝试解决"}},[t._v("#")]),t._v(" 尝试解决")]),t._v(" "),a("ol",[a("li",[t._v("不挂载，使用var或let进行定义成全局变量，这样确实会解决这个问题，但是又会造成另一个问题，当路由切换时，我们需要在beforedestory中主动调用地图销毁事件。更何况这么写并不美观。")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze",target:"_blank",rel:"noopener noreferrer"}},[t._v("Object.freeze()"),a("OutboundLink")],1),t._v(",考虑过使用此方法解决监听问题，但是这样会导致地图实例无法变化，造成地图报错，此思路走不通。")])]),t._v(" "),a("h2",{attrs:{id:"最终解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最终解决"}},[t._v("#")]),t._v(" 最终解决")]),t._v(" "),a("p",[t._v("仍然走Vue挂载方式，但是这次挂载并不在data中声明，这样挂载的变量不会触发数据监听，也不会影响地图实例的性能。")])])}),[],!1,null,null,null);e.default=s.exports}}]);